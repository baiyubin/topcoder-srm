import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class TheKingsRoadsDiv2
{
    int n, h;
    ArrayList<ArrayList<Integer>> adj = new ArrayList<ArrayList<Integer>>();
    ArrayList<ArrayList<Integer>> deg;
	public String getAnswer(int h, int[] a, int[] b)
	{
        this.h = h;
		this.n = (1 << h) - 1;
        for (int i = 0; i < n + 1; i++) {
            adj.add(new ArrayList<Integer>());
        }
        for (int i = 0; i < n; i++) {
            adj.get(a[i]).add(b[i]);
            if (a[i] != b[i]) adj.get(b[i]).add(a[i]);
        }
        for (int i = 0; i < n; i++) {
            int p;
            p = adj.get(a[i]).indexOf(b[i]);
            adj.get(a[i]).remove(p);
            if (a[i] != b[i]) {
                p = adj.get(b[i]).indexOf(a[i]);
                adj.get(b[i]).remove(p);
            }
            if (validDegrees(adj) && validLayout(adj)) {
                return "Correct";
            }
            adj.get(a[i]).add(b[i]);
            if (a[i] != b[i]) adj.get(b[i]).add(a[i]);
        }
        return "Incorrect";
    }

    private boolean validLayout(ArrayList<ArrayList<Integer>> adj) {
        boolean[] seen = new boolean[n + 1];
        ArrayDeque<Integer> currLevel = new ArrayDeque<Integer>();
        ArrayDeque<Integer> nextLevel = new ArrayDeque<Integer>();
        int root = deg.get(2).get(0);
        currLevel.add(root);
        seen[root] = true;
        for (int i = 0; i < h - 1; i++) {
            nextLevel = new ArrayDeque<Integer>();
            for (int u : currLevel) {
                for (int v : adj.get(u)) {
                    if (!seen[v]) {
                        nextLevel.add(v);
                        seen[v] = true;
                    }
                }
            }
            if (nextLevel.size() != 2 * currLevel.size()) {
                return false;
            } else {
                currLevel = nextLevel;
            }
        }
        return true;
    }

    private boolean validDegrees(ArrayList<ArrayList<Integer>> adj) {
        deg = new ArrayList<ArrayList<Integer>>();
        for (int i = 0; i < 5; i++) {
            deg.add(new ArrayList<Integer>());
        }
        for (int i = 1; i <= n; i++) {
            int size = adj.get(i).size();
            if (size < deg.size()) {
                deg.get(size).add(i);
            }
        }
        return  (deg.get(2).size() == 1)
                && (deg.get(1).size() == (n + 1) / 2)
                && (deg.get(3).size() == n - (n + 1) / 2 - 1);
    }

    // BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, int p0, int[] p1, int[] p2, boolean hasAnswer, String p3) {
		System.out.print("Test " + testNum + ": [" + p0 + "," + "{");
		for (int i = 0; p1.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p1[i]);
		}
		System.out.print("}" + "," + "{");
		for (int i = 0; p2.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p2[i]);
		}
		System.out.print("}");
		System.out.println("]");
		TheKingsRoadsDiv2 obj;
		String answer;
		obj = new TheKingsRoadsDiv2();
		long startTime = System.currentTimeMillis();
		answer = obj.getAnswer(p0, p1, p2);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + "\"" + p3 + "\"");
		}
		System.out.println("Your answer:");
		System.out.println("\t" + "\"" + answer + "\"");
		if (hasAnswer) {
			res = answer.equals(p3);
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		int p0;
		int[] p1;
		int[] p2;
		String p3;
        // ----- test 0 -----
        p0 = 3;
        p1 = new int[]{4, 7, 7, 1, 1, 1, 4};
        p2 = new int[]{6, 5, 1, 7, 4, 3, 2};
        p3 = "Incorrect";
        all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
        // ------------------
		// ----- test 0 -----
		p0 = 3;
		p1 = new int[]{1,2,3,7,1,5,4};
		p2 = new int[]{6,7,4,3,3,1,7};
		p3 = "Correct";
		all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = 2;
		p1 = new int[]{1,2,3};
		p2 = new int[]{2,1,3};
		p3 = "Incorrect";
		all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = 3;
		p1 = new int[]{7,1,1,2,2,3,1};
		p2 = new int[]{7,1,7,4,5,2,6};
		p3 = "Incorrect";
		all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = 2;
		p1 = new int[]{1,3,3};
		p2 = new int[]{2,1,2};
		p3 = "Correct";
		all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
		// ------------------
		
		// ----- test 4 -----
		p0 = 3;
		p1 = new int[]{6,5,3,3,5,5,6};
		p2 = new int[]{1,5,5,6,4,7,2};
		p3 = "Correct";
		all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
		// ------------------
		
		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// 
	// You live in the Kingdom of Byteland.
	// The kingdom has a very interesting history.
	// It has already existed for h years.
	// During the first year of its existence the inhabitants built the first city.
	// During each of the next h-1 years the following procces occurred:
	// For each city built in the previous year, two additional cities were built and the older city was connected to each the two new cities by a bidirecional road.
	// Now, after h full years, the kingdom contains exactly (2^h)-1 cities and (2^h)-2 roads.
	// 
	// 
	// 
	// 
	// Recently the King did two changes to the kingdom.
	// First, he numbered the cities from 1 to (2^h)-1 in an arbitrary way.
	// Then, he added exactly one new road to the kingdom.
	// (The road could have connected two cities that were already connected by a different road.
	// Also, it is possible that the new road connected some city to itself.)
	// 
	// 
	// 
	// 
	// You are given the int h and two int[]s a and b with (2^h)-1 elements each.
	// For each valid i, there is a road between the cities a[i] and b[i].
	// 
	// 
	// 
	// 
	// Return "Correct" if it is possible that the given list of roads is the current road network in the Kingdom of Byteland.
	// Otherwise, return "Incorrect".
	// 
	// 
	// DEFINITION
	// Class:TheKingsRoadsDiv2
	// Method:getAnswer
	// Parameters:int, int[], int[]
	// Returns:String
	// Method signature:String getAnswer(int h, int[] a, int[] b)
	// 
	// 
	// CONSTRAINTS
	// -h will be between 2 and 10, inclusive.
	// -a and b will contain exactly (2^h)-1 elements each.
	// -Each element of a and b will be between 1 and (2^h)-1, inclusive.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// 3
	// {1, 2, 3, 7, 1, 5, 4}
	// {6, 7, 4, 3, 3, 1, 7}
	// 
	// Returns: "Correct"
	// 
	// City 3 was built during the first year, cities 1 and 7 during the second year, and the other four cities during the third year.
	// Then the King added the road 3-4.
	// 
	// 1)
	// 2
	// {1, 2, 3}
	// {2, 1, 3}
	// 
	// Returns: "Incorrect"
	// 
	// 
	// 
	// 2)
	// 3
	// {7, 1, 1, 2, 2, 3, 1}
	// {7, 1, 7, 4, 5, 2, 6}
	// 
	// Returns: "Incorrect"
	// 
	// 
	// 
	// 3)
	// 2
	// {1, 3, 3}
	// {2, 1, 2}
	// 
	// Returns: "Correct"
	// 
	// 
	// 
	// 4)
	// 3
	// {6, 5, 3, 3, 5, 5, 6}
	// {1, 5, 5, 6, 4, 7, 2}
	// 
	// Returns: "Correct"
	// 
	// Here the road added by the King is obviously the self-loop from city 5 to itself.
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
