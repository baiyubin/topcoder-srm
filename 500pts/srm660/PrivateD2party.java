import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class PrivateD2party {
	public int getsz(int[] a) {
		int n = a.length;
		int cycles = 0;

		for (int i = 0; i < n; i++) {
			if (isCycle(a, i)) cycles++;
		}
		return n - cycles;
	}
	private boolean isCycle(int[] a, int start) {
		if (a[start] == start) return false;

		HashSet<Integer> s = new HashSet<Integer>();
		s.add(start);
		int p = a[start];
		while (!s.contains(p)) {
			s.add(p);
			p = a[p];
		}
		if (p != a[p]) {
			a[p] = p;
			return true;
		} else {
			return false;
		}
	}

	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, int[] p0, boolean hasAnswer, int p1) {
		System.out.print("Test " + testNum + ": [" + "{");
		for (int i = 0; p0.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p0[i]);
		}
		System.out.print("}");
		System.out.println("]");
		PrivateD2party obj;
		int answer;
		obj = new PrivateD2party();
		long startTime = System.currentTimeMillis();
		answer = obj.getsz(p0);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p1);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p1;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;

		int[] p0;
		int p1;

		// ----- test 0 -----
		p0 = new int[] {0, 1};
		p1 = 2;
		all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
		// ------------------

		// ----- test 1 -----
		p0 = new int[] {1, 0};
		p1 = 1;
		all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
		// ------------------

		// ----- test 2 -----
		p0 = new int[] {1, 0, 3, 2};
		p1 = 2;
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------

		// ----- test 3 -----
		p0 = new int[] {5, 2, 2, 4, 5, 0};
		p1 = 5;
		all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
		// ------------------

		// ----- test 4 -----
		p0 = new int[] {3, 2, 1, 0, 5, 4};
		p1 = 3;
		all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
		// ------------------
		// ----- test 4 -----
		p0 = new int[] {18, 9, 7, 18, 6, 14, 24, 8, 3, 21, 10, 0, 18, 23, 24, 0, 13, 3, 9, 18, 13, 19, 1, 6, 15};
		p1 = 24;
		all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
		// ------------------

		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// Hero is inviting his friends to the party.
	// He has n friends, numbered 0 through n-1.
	// For each of his friends there is at most one other person the friend dislikes.
	// You are given this information as a int[] a with n elements.
	// For each i, a[i] is either the number of the person disliked by friend i, we have a[i]=i if friend i likes everybody else.
	//
	// Hero is inviting his friends one at a time.
	// Whenever he invites friend i, they will accept if and only if the friend a[i] didn't accept an earlier invitation.
	// (That includes two cases: either Hero didn't invite friend a[i] yet, or he did but the friend rejected the invitation.)
	//
	// Hero noticed that the order in which he invites his friends matters: different orders may produce different numbers of accepted invitations.
	//
	// Find an order that will produce the most accepted invitations, and return their number.
	//
	//
	// DEFINITION
	// Class:PrivateD2party
	// Method:getsz
	// Parameters:int[]
	// Returns:int
	// Method signature:int getsz(int[] a)
	//
	//
	// CONSTRAINTS
	// -a will contain exactly n elements.
	// -n will be between 1 and 50, inclusive.
	// -Each element of a will be between 0 and n - 1, inclusive.
	//
	//
	// EXAMPLES
	//
	// 0)
	// {0,1}
	//
	// Returns: 2
	//
	// Each of the friends likes the other. Regardless of the order in which Hero asks them, they will both accept the invitation.
	//
	// 1)
	// {1,0}
	//
	// Returns: 1
	//
	// Friend 0 dislikes friend 1 and vice versa. The first friend Hero asks will accept the invitation but then the other friend will certainly reject it.
	//
	// 2)
	// {1,0,3,2}
	//
	// Returns: 2
	//
	//
	//
	// 3)
	// {5,2,2,4,5,0}
	//
	// Returns: 5
	//
	// Here is what would happen if Hero invited the friends in the order (0,1,2,3,4,5):
	//
	// Friend 5 didn't accept yet, so friend 0 would accept.
	// Friend 2 didn't accept yet, so friend 1 would accept.
	// Friend 2 likes everybody and therefore they would accept.
	// Friend 4 didn't accept yet, so friend 3 would accept.
	// Friend 5 didn't accept yet, so friend 4 would accept.
	// Friend 0 did already accept, therefore friend 5 would reject.
	//
	// It turns out that this solution happens to be optimal: there is no order such that all six friends would accept the invitations.
	//
	// 4)
	// {3,2,1,0,5,4}
	//
	// Returns: 3
	//
	//
	//
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
