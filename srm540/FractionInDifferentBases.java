import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class FractionInDifferentBases
{
	public long getNumberOfGoodBases(long P, long Q, long A, long B)
	{
		long g = gcd(P, Q);
		long q = Q / g;
		// p / q in basis b is finite iff 1/q in basis b is finite

		// let pp be the product of prime factors of q
		// 1/q in basis b is finite iff b is a multiple of pp
		long pp = 1;
		for (int i = 2; i < 1e6; ++i) {
		    if (q % i == 0) {
		    	pp *= i;
		    	while (q % i == 0) {
		    		q /= i;
		    	}
		    }
		}
		if (q != 1) {
			pp *= q;
		}
		return (B - A + 1) - (B / pp - (A - 1) / pp);
	}
	public long gcd(long a, long b) {
		long t = 0;
		while (b != 0) {
			t = b;
			b = a % b;
			a = t;
		}
		return a;
	}
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, long p0, long p1, long p2, long p3, boolean hasAnswer, long p4) {
		System.out.print("Test " + testNum + ": [" + p0 + "," + p1 + "," + p2 + "," + p3);
		System.out.println("]");
		FractionInDifferentBases obj;
		long answer;
		obj = new FractionInDifferentBases();
		long startTime = System.currentTimeMillis();
		answer = obj.getNumberOfGoodBases(p0, p1, p2, p3);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p4);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p4;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		long p0;
		long p1;
		long p2;
		long p3;
		long p4;
		
		// ----- test 0 -----
		p0 = 1L;
		p1 = 2L;
		p2 = 10L;
		p3 = 10L;
		p4 = 0L;
		all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = 1L;
		p1 = 9L;
		p2 = 9L;
		p3 = 10L;
		p4 = 1L;
		all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = 5L;
		p1 = 6L;
		p2 = 2L;
		p3 = 10L;
		p4 = 8L;
		all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = 2662L;
		p1 = 540L;
		p2 = 2L;
		p3 = 662L;
		p4 = 639L;
		all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) && all_right;
		// ------------------
		
		// ----- test 4 -----
		p0 = 650720L;
		p1 = 7032600L;
		p2 = 2012L;
		p3 = 2012540L;
		p4 = 2010495L;
		all_right = KawigiEdit_RunTest(4, p0, p1, p2, p3, true, p4) && all_right;
		// ------------------
		
		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// 
	// This problem statement contains superscripts and/or subscripts. It may not display properly outside the applet.
	// 
	// It is well-known that when writing a fraction as a rational number, we will either get a finite expansion or an infinite (but periodic) expansion.
	// For example, 1/8 written in base 10 is 0.125, and 1/9 written in base 10 is 0.1111...
	// 
	// The same fraction can have a finite expansion in some bases and an infinite one in other bases.
	// For example, 1/9 had an infinite expansion in base 10, but 1/9 written in base 3 is 0.01 and 1/9 in base 9 is 0.1.
	// 
	// Little Arthur loves numbers and especially the ones that are infinitely long. For a given fraction P/Q he would like to find all integer bases between A and B, inclusive, such that the fraction has an infinite expansion.
	// 
	// Given ints P, Q, A, and B return the number of such bases.
	// 
	// DEFINITION
	// Class:FractionInDifferentBases
	// Method:getNumberOfGoodBases
	// Parameters:long, long, long, long
	// Returns:long
	// Method signature:long getNumberOfGoodBases(long P, long Q, long A, long B)
	// 
	// 
	// NOTES
	// -Number X written in an integer base b is a sequence of digits (containing a single separator point, if the number is not an integer) dndn-1..d1d0.d-1..d-m where each di has an integer value between 0 and b-1, inclusive.
	// -The notation effectively means that X = dn*bn + dn-1*bn-1 + .. + d1*b1 + d0*b0 + d-1*b-1 + .. + d-m*b-m.
	// -Note that X having an infinite expansion in base b means that number X cannot be expressed as a sum with finitely many powers of b.
	// 
	// 
	// CONSTRAINTS
	// -P will be between 0 and 1000000000000 (1012), inclusive.
	// -Q will be between 1 and 1000000000000 (1012), inclusive.
	// -A and B will each be between 2 and 1000000000000000000 (1018), inclusive.
	// -A will be less than or equal to B.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// 1
	// 2
	// 10
	// 10
	// 
	// Returns: 0
	// 
	// 1/2 in base 10 is 0.5, thus, there is no base in the interval where 1/2 has an infinite expansion.
	// 
	// 1)
	// 1
	// 9
	// 9
	// 10
	// 
	// Returns: 1
	// 
	// From the problem statement we see that 1/9 has an infinite expansion in base 10, but not in base 9.
	// 
	// 2)
	// 5
	// 6
	// 2
	// 10
	// 
	// Returns: 8
	// 
	// 3)
	// 2662
	// 540
	// 2
	// 662
	// 
	// Returns: 639
	// 
	// 4)
	// 650720
	// 7032600
	// 2012
	// 2012540
	// 
	// Returns: 2010495
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
