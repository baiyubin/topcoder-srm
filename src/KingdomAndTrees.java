import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class KingdomAndTrees
{
    private final int INF = (int) 1e10;
	public int minLevel(int[] heights)
	{
        int left = 0, right = INF;
        while (left < right) {
            int mid = (left + right) >> 1;
            if (valid(heights, mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
		return left;
	}

    /**
     * construct solution in a greedy way
     * @param heights
     * @param move
     * @return
     */
    private boolean valid(int[] heights, int move) {
        int n = heights.length;
        int[] arr = Arrays.copyOf(heights, n);
        arr[0] = Math.max(1, arr[0] - move);
        for (int i = 1; i < n; i++) {
            int sm = arr[i] - move, bg = arr[i] + move;
            int prev = arr[i - 1];
            if (prev + 1 <= bg && sm <= prev + 1) {
                arr[i] = prev + 1;
            } else if (sm > prev) {
                arr[i] = sm;
            } else {
                return false;
            }
        }

        return true;
    }

    // BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, int[] p0, boolean hasAnswer, int p1) {
		System.out.print("Test " + testNum + ": [" + "{");
		for (int i = 0; p0.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p0[i]);
		}
		System.out.print("}");
		System.out.println("]");
		KingdomAndTrees obj;
		int answer;
		obj = new KingdomAndTrees();
		long startTime = System.currentTimeMillis();
		answer = obj.minLevel(p0);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p1);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p1;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		int[] p0;
		int p1;
		
		// ----- test 0 -----
		p0 = new int[]{9,5,11};
		p1 = 3;
		all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = new int[]{5,8};
		p1 = 0;
		all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = new int[]{1,1,1,1,1};
		p1 = 4;
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = new int[]{548,47,58,250,2012};
		p1 = 251;
		all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
		// ------------------
		
		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// King Dengklek once planted N trees, conveniently numbered 0 through N-1, along the main highway in the Kingdom of Ducks. As time passed, the trees grew beautifully. Now, the height of the i-th tree is heights[i] units.
	// 
	// King Dengklek now thinks that the highway would be even more beautiful if the tree heights were in strictly ascending order. More specifically, in the desired configuration the height of tree i must be strictly smaller than the height of tree i+1, for all possible i. To accomplish this, King Dengklek will cast his magic spell. If he casts magic spell of level X, he can increase or decrease the height of each tree by at most X units. He cannot decrease the height of a tree into below 1 unit. Also, the new height of each tree in units must again be an integer.
	// 
	// Of course, a magic spell of a high level consumes a lot of energy. Return the smallest possible non-negative integer X such that King Dengklek can achieve his goal by casting his magic spell of level X.
	// 
	// DEFINITION
	// Class:KingdomAndTrees
	// Method:minLevel
	// Parameters:int[]
	// Returns:int
	// Method signature:int minLevel(int[] heights)
	// 
	// 
	// CONSTRAINTS
	// -heights will contain between 2 and 50 elements, inclusive.
	// -Each elements of heights will be between 1 and 1,000,000,000, inclusive.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// {9, 5, 11}
	// 
	// Returns: 3
	// 
	// One possible solution that uses magic spell of level 3:
	// 
	// Decrease the height of the first tree by 2 units.
	// Increase the height of the second tree by 3 units.
	// 
	// The resulting heights are {7, 8, 11}.
	// 
	// 1)
	// {5, 8}
	// 
	// Returns: 0
	// 
	// These heights are already sorted in strictly ascending order.
	// 
	// 2)
	// {1, 1, 1, 1, 1}
	// 
	// Returns: 4
	// 
	// Since King Dengklek cannot decrease the heights of the trees below 1, the only possible solution is to cast his magic spell of level 4 to transform these heights into {1, 2, 3, 4, 5}.
	// 
	// 3)
	// {548, 47, 58, 250, 2012}
	// 
	// Returns: 251
	// 
	// 
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
