import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;

/**
 * srm640
 */
public class NumberGameAgain
{
	public long solve(int k, long[] table)
	{
		long all = (1L << k);
        long ret = all - 2;
        Arrays.sort(table);
        int n = table.length;
        for (int i = 0; i < n; i++) {
            boolean isSub = false;
            for (int j = 0; j < i; j++) {
                if (isSubtree(table[j], table[i])) {
                    isSub = true;
                    break;
                }
            }
            if (!isSub) {
                long subtreeLen = k - bitLen(table[i]) + 1;
                ret -= (1L << subtreeLen) - 1;
            }
        }
        return ret;
	}

    private boolean isSubtree(long root, long twig) {
        while (bitLen(root) < bitLen(twig)) {
            twig >>= 1;
        }
        return root == twig;
    }

    private short bitLen(long l) {
        short ret = 0;
        while (l != 0) {
            l >>= 1;
            ret++;
        }
        return ret;
    }

    // BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, int p0, long[] p1, boolean hasAnswer, long p2) {
		System.out.print("Test " + testNum + ": [" + p0 + "," + "{");
		for (int i = 0; p1.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p1[i]);
		}
		System.out.print("}");
		System.out.println("]");
		NumberGameAgain obj;
		long answer;
		obj = new NumberGameAgain();
		long startTime = System.currentTimeMillis();
		answer = obj.solve(p0, p1);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p2);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p2;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		int p0;
		long[] p1;
		long p2;

        // ----- test 4 -----
        p0 = 40;
        p1 = new long[]{};
        p2 = 1099511627774L;
        all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
        // ------------------

		// ----- test 0 -----
		p0 = 3;
		p1 = new long[]{2L,4L,6L};
		p2 = 2L;
		all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = 5;
		p1 = new long[]{2L,3L};
		p2 = 0L;
		all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = 5;
		p1 = new long[]{};
		p2 = 30L;
		all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = 40;
		p1 = new long[]{2L,4L,8L,16L,32141531L,2324577L,1099511627775L,2222222222L,33333333333L,4444444444L,2135L};
		p2 = 549755748288L;
		all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
		// ------------------

		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// 
	// In this problem, you are going to play a simple number game.
	// The rules of the game are as follows:
	// 
	// You have a single variable called x. Initially, x is set to 1.
	// In each step, you can change the value of x either to 2x or to 2x+1.
	// You are given a list of forbidden values. If at any moment your x is on the list, you lose the game.
	// You are also given a target value y. If at any moment your x is equal to y, you win the game. (Note that the previous item applies sooner: if y is forbidden, you lose the game when you reach it.)
	// If at any moment winning the game becomes impossible, you lose the game.
	// 
	// 
	// 
	// 
	// For example, assume that the forbidden values are 4 and 7, and the goal is 12.
	// You can win the game as follows: change x from 1 to 2*1+1=3, then from 3 to 2*3=6, and then from 6 to 2*6=12.
	// 
	// 
	// 
	// You are given a long[] table.
	// The elements of table are the forbidden values.
	// 
	// 
	// 
	// You are also given a int k.
	// Consider all possible goals y between 2 and (2^k)-1, inclusive.
	// For how many of these goals is it possible to win the game?
	// Compute and return the answer to that question.
	// 
	// 
	// DEFINITION
	// Class:NumberGameAgain
	// Method:solve
	// Parameters:int, long[]
	// Returns:long
	// Method signature:long solve(int k, long[] table)
	// 
	// 
	// CONSTRAINTS
	// -k will be between 2 and 40, inclusive.
	// -The number of elements in table will be between 0 and 20, inclusive.
	// -all numbers in table will be between 2 and 2^k - 1, inclusive.
	// -all numbers in table will be distinct.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// 3
	// {2,4,6}
	// 
	// Returns: 2
	// 
	// There are three forbidden values: 2, 4, and 6.
	// As k=3, we are considering y between 2 and (2^3)-1 = 7.
	// This is how the game would end for each of these y's:
	// 
	// For y=2 we cannot win the game because 2 is forbidden.
	// For y=3 we can win the game: we change x from 1 to 3.
	// For y=4 we cannot win the game because 4 is forbidden.
	// For y=5 we cannot win the game. We would need to change x from 1 to 2 and then from 2 to 5, but we cannot do that because 2 is forbidden.
	// For y=6 we cannot win the game because 6 is forbidden.
	// For y=7 we can win the game: we change x from 1 to 3, and then from 3 to 7.
	// 
	// Thus, within the specified range there are two values of y for which we can win the game.
	// 
	// 
	// 1)
	// 5
	// {2,3}
	// 
	// Returns: 0
	// 
	// In this case, we will always reach a forbidden value after the very first step of the game. Therefore, there is no y for which we can win the game.
	// 
	// 2)
	// 5
	// {}
	// 
	// Returns: 30
	// 
	// With no forbidden values we can win this game for any y between 2 and 31, inclusive.
	// 
	// 3)
	// 40
	// {2,4,8,16,32141531,2324577,1099511627775,2222222222,33333333333,4444444444,2135}
	// 
	// Returns: 549755748288
	// 
	// 
	// 
	// 4)
	// 40
	// {}
	// 
	// Returns: 1099511627774
	// 
	// 
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
