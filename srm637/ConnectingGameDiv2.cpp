#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

class Node {

public:
    char c;
    int w;
    Node(char cc, int ww)
    {
        this->c = cc;
        this->w = ww;
    }
    bool operator < (const Node& rhs) const
    {
        return w < rhs.w;
    }

};

const int nn = 60;

class ConnectingGameDiv2 {
public:
    map<char, set<char> > adjList;
    map<char, int> weight;
    int minCost = (int) 1e9;
    const int direct[8][2] = {{0, 1} ,{1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1},{-1, 0}, {-1, 1} };
    int n, m;
    int MAX_INT = (int) 1e9;
    char seen[nn][nn];
    int getmin(vector <string> board) {
        n = (int) board.size();
        m = (int) board[0].length();

        floodfill(board, 0, 0);
        char start = '^', end = '$';

        weight[start] = weight[end] = 0;

        for (int i = 0; i < n; i++) {
            adjList[start].insert(board[i][0]);
            adjList[board[i][m - 1]].insert(end);
        }
        dijkstra(start, end);
        return minCost;
    }
    void floodfill(vector<string> board, int r, int c) {
        seen[r][c] = true;
        char curr = board[r][c];
        if (weight[curr]) {
            weight[curr]++;
        } else {
            weight[curr] = 1;
        }
        for (auto& d : direct) {
            int rr = r + d[0];
            int cc = c + d[1];
            if (rr >= 0 && rr < n && cc >= 0 && cc < m) {
                char adjCurr = board[rr][cc];
                if (adjCurr != curr) {
                    adjList[curr].insert(adjCurr);
                }
                if (!seen[rr][cc]) floodfill(board, rr, cc);
            }
        }
    }
    void dijkstra(char start, char end) {
        priority_queue<Node> q;
        map<char, int> dist;
        q.push(Node(start, 0));
        dist[start] = 0;
        for (auto& kv : weight) {
            if (kv.first != start) {
                q.push(Node(kv.first, MAX_INT));
                dist[kv.first] = MAX_INT;
            }
        }
        while (!q.empty()) {
            Node e = q.top();
            q.pop();
            if (dist[e.c] < e.w) continue;
            dist[e.c] = e.w;
            for (char child : adjList[e.c]) {
                int newDist = e.w + weight[e.c];
                int oldDist = dist[child];
                if (oldDist > newDist) {
                    dist[child] = newDist;
                    q.push(Node(child, newDist));
                }
            }
        }
        minCost = dist[end];
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
    cout << "Test " << testNum << ": [" << "{";
    for (int i = 0; int(p0.size()) > i; ++i) {
        if (i > 0) {
            cout << ",";
        }
        cout << "\"" << p0[i] << "\"";
    }
    cout << "}";
    cout << "]" << endl;
    ConnectingGameDiv2 *obj;
    int answer;
    obj = new ConnectingGameDiv2();
    clock_t startTime = clock();
    answer = obj->getmin(p0);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer) {
        cout << "Desired answer:" << endl;
        cout << "\t" << p1 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer) {
        res = answer == p1;
    }
    if (!res) {
        cout << "DOESN'T MATCH!!!!" << endl;
    } else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
        cout << "FAIL the timeout" << endl;
        res = false;
    } else if (hasAnswer) {
        cout << "Match :-)" << endl;
    } else {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main() {
    bool all_right;
    all_right = true;
    
    vector <string> p0;
    int p1;
    
    {
        // ----- test 0 -----
        string t0[] = {"AA","BC"};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        p1 = 2;
        all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
        // ------------------
    }
    
    {
        // ----- test 1 -----
        string t0[] = {"AAB","ACD","CCD"};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        p1 = 4;
        all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
        // ------------------
    }
    
    {
        // ----- test 2 -----
        string t0[] = {"iii","iwi","iii"};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        p1 = 8;
        all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
        // ------------------
    }
    
    {
        // ----- test 3 -----
        string t0[] = {"rng58","Snuke","Sothe"};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        p1 = 6;
        all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
        // ------------------
    }
    
    {
        // ----- test 4 -----
        string t0[] = {"yyAArJqjWTH5","yyEEruYYWTHG","hooEvutpkkb2","OooNgFFF9sbi","RRMNgFL99Vmm","R76XgFF9dVVV","SKnZUPf88Vee"};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        p1 = 14;
        all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
        // ------------------
    }
    
    if (all_right) {
        cout << "You're a stud (at least on the example cases)!" << endl;
    } else {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
// Cat Snuke and wolf Sothe are playing the Connecting Game.
//
// The Connecting Game is played on a rectangular grid that is divided into unit square cells.
// The grid is divided into some regions.
// Each cell belongs into exactly one of those regions.
// Each region is 4-connected (see Notes for a formal definition).
//
// You are given a vector <string> board that describes the division of the grid into regions.
// Each character in board represents one of the cells.
// Cells that are represented by the same character belong into the same region.
//
// Initially, the entire grid is colorless.
// The game consists of two steps.
// In the first step, Snuke colors some of the regions red.
// In the second step, Sothe colors all remaining regions blue.
// (Within each region, all cells must have the same color.)
// Sothe wins if there is a path (see Notes for a formal definition) of blue cells from the top row to the bottom row.
// Otherwise, Snuke wins.
//
// You are given the vector <string> board.
// Compute and return the smallest number of cells Snuke can color red in order to win the game.
//
// (Note that Snuke cannot simply color individual cells, he must color entire regions.
// Also note that we are interested in minimizing the total number of cells, not the number of regions Snuke colors.)
//
// DEFINITION
// Class:ConnectingGameDiv2
// Method:getmin
// Parameters:vector <string>
// Returns:int
// Method signature:int getmin(vector <string> board)
//
//
// NOTES
// -A path is a sequence of cells such that each pair of consecutive cells shares a common side.
// -A region is 4-connected if for any two cells A and B in that region there is a path that starts with A, ends with B, and only contains cells from that region.
//
//
// CONSTRAINTS
// -board will contain between 1 and 50 elements, inclusive.
// -Each element in board will contain between 1 and 50 characters, inclusive.
// -All elements in board will have the same length.
// -Each character in board will be a letter or a digit ('a'-'z', 'A'-'Z', or '0'-'9').
// -Each of the regions in board will be 4-connected.
//
//
// EXAMPLES
//
// 0)
// {"AA"
// ,"BC"}
//
// Returns: 2
//
// If Snuke colors 0 or 1 cells red, he will lose the game. He can win the game by coloring 2 cells red. One possibility is to color the two 'A' cells red.
//
// 1)
// {"AAB"
// ,"ACD"
// ,"CCD"}
//
// Returns: 4
//
// Here, one optimal solution is to color the regions 'B' and 'C' red. There will be 1 + 3 = 4 red cells.
// 
// 2)
// {"iii"
// ,"iwi"
// ,"iii"}
// 
// Returns: 8
// 
// 
// 
// 3)
// {"rng58"
// ,"Snuke"
// ,"Sothe"}
// 
// Returns: 6
// 
// 
// 
// 4)
// {"yyAArJqjWTH5","yyEEruYYWTHG","hooEvutpkkb2","OooNgFFF9sbi","RRMNgFL99Vmm","R76XgFF9dVVV","SKnZUPf88Vee"}
// 
// Returns: 14
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
