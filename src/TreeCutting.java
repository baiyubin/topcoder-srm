import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class TreeCutting
{
	/**
	 * srm 644
	 * 		contract single ended tree twig to the node that has a weight
	 * 		adjacent nodes that have weights must be separated
	 * 		each cut generates a new component
	 * @param  par [description]
	 * @param  num [description]
	 * @return     [description]
	 */
	public String can(int[] par, int[] num)
	{
		return "";
	}
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, int[] p0, int[] p1, boolean hasAnswer, String p2) {
		System.out.print("Test " + testNum + ": [" + "{");
		for (int i = 0; p0.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p0[i]);
		}
		System.out.print("}" + "," + "{");
		for (int i = 0; p1.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p1[i]);
		}
		System.out.print("}");
		System.out.println("]");
		TreeCutting obj;
		String answer;
		obj = new TreeCutting();
		long startTime = System.currentTimeMillis();
		answer = obj.can(p0, p1);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + "\"" + p2 + "\"");
		}
		System.out.println("Your answer:");
		System.out.println("\t" + "\"" + answer + "\"");
		if (hasAnswer) {
			res = answer.equals(p2);
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		int[] p0;
		int[] p1;
		String p2;
		
		// ----- test 0 -----
		p0 = new int[]{0,1,2,2,2};
		p1 = new int[]{2,-1,-1,4,-1,-1};
		p2 = "POSSIBLE";
		all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = new int[]{0,1,2,2,2};
		p1 = new int[]{3,-1,-1,3,-1,-1};
		p2 = "IMPOSSIBLE";
		all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = new int[]{0,1,2,2,2};
		p1 = new int[]{2,-1,-1,3,-1,-1};
		p2 = "IMPOSSIBLE";
		all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = new int[]{0,1,2,2,1,5,2,6,6};
		p1 = new int[]{-1,-1,2,-1,1,3,-1,1,1,2};
		p2 = "POSSIBLE";
		all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 4 -----
		p0 = new int[]{0,1,2,2,1,5,2,6,6};
		p1 = new int[]{-1,-1,2,-1,1,-1,3,1,1,2};
		p2 = "IMPOSSIBLE";
		all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 5 -----
		p0 = new int[]{0,0,0,0,1,1,2,3,3,3,4,4,4,5,9,9,14,14,14,16,20};
		p1 = new int[]{-1,3,-1,-1,-1,-1,-1,1,1,-1,-1,-1,3,1,-1,1,8,-1,-1,4,-1,-1};
		p2 = "POSSIBLE";
		all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 6 -----
		p0 = new int[]{0,0,0,0,1,1,2,3,3,3,4,4,4,5,9,9,14,14,14,16,20};
		p1 = new int[]{-1,2,-1,-1,-1,-1,-1,1,1,-1,-1,-1,3,1,-1,1,9,-1,-1,4,-1,-1};
		p2 = "IMPOSSIBLE";
		all_right = KawigiEdit_RunTest(6, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 7 -----
		p0 = new int[]{0,0,1,1};
		p1 = new int[]{-1,-1,5,-1,-1};
		p2 = "POSSIBLE";
		all_right = KawigiEdit_RunTest(7, p0, p1, true, p2) && all_right;
		// ------------------
		
		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// Wolf Sothe has an undirected tree with N vertices, numbered 0 through N-1.
	// You are given the description of the tree as a int[] par with N-1 elements.
	// For each valid i, the tree contains the edge between vertices (i+1) and par[i].
	// (Note that for your convenience par[i] is always smaller than i+1.)
	// 
	// Some of the vertices contain a positive integer, others are empty.
	// You are given a int[] num with N elements.
	// For each valid i, num[i] is either the number written in vertex i, or -1 if vertex i is empty.
	// 
	// Sothe can modify the tree by cutting some of its edges.
	// Sothe's goal is to reach a configuration with the following properties:
	// 
	// 
	// Each connected component contains exactly one vertex with an integer.
	// 
	// 
	// The number of vertices in each component is equal to the only integer in that component.
	// 
	// 
	// 
	// Return "POSSIBLE" (quotes for clarity) if Sothe can reach some configuration with the desired properties by cutting zero or more edges.
	// Otherwise, return "IMPOSSIBLE".
	// Note that the return value is case-sensitive.
	// 
	// DEFINITION
	// Class:TreeCutting
	// Method:can
	// Parameters:int[], int[]
	// Returns:String
	// Method signature:String can(int[] par, int[] num)
	// 
	// 
	// CONSTRAINTS
	// -N will be between 1 and 50, inclusive.
	// -par will contain exactly N-1 elements.
	// -For each i, the i-th element of par will be between 0 and i, inclusive.
	// -num will contain exactly N elements.
	// -Each element in num will be either -1 or between 1 and N, inclusive.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// {0,1,2,2,2}
	// {2,-1,-1,4,-1,-1}
	// 
	// Returns: "POSSIBLE"
	// 
	// This is a tree with 6 vertices.
	// The edges are 1-0, 2-1, 3-2, 4-2, and 5-2.
	// Vertex 0 contains the integer 2, vertex 3 contains the integer 4, and all other vertices are empty.
	// 
	// Sothe can reach his goal by cutting the edge 1-2.
	// This will produce two components.
	// In one component we have the vertices {0,1}.
	// One of them contains the number 2 (which is also the size of this component) and the other is empty.
	// In the other component we have the vertices {2,3,4,5}.
	// One of them contains the number 4 (which is also the size of this component) and the other three are empty.
	// 
	// 1)
	// {0,1,2,2,2}
	// {3,-1,-1,3,-1,-1}
	// 
	// Returns: "IMPOSSIBLE"
	// 
	// 
	// 
	// 2)
	// {0,1,2,2,2}
	// {2,-1,-1,3,-1,-1}
	// 
	// Returns: "IMPOSSIBLE"
	// 
	// The tree has 6 vertices but in any valid final configuration the components must have 2+3 = 5 vertices, which is impossible.
	// 
	// 3)
	// {0,1,2,2,1,5,2,6,6}
	// {-1,-1,2,-1,1,3,-1,1,1,2}
	// 
	// Returns: "POSSIBLE"
	// 
	// 
	// 
	// 4)
	// {0,1,2,2,1,5,2,6,6}
	// {-1,-1,2,-1,1,-1,3,1,1,2}
	// 
	// Returns: "IMPOSSIBLE"
	// 
	// 
	// 
	// 5)
	// {0,0,0,0,1,1,2,3,3,3,4,4,4,5,9,9,14,14,14,16,20}
	// {-1,3,-1,-1,-1,-1,-1,1,1,-1,-1,-1,3,1,-1,1,8,-1,-1,4,-1,-1}
	// 
	// Returns: "POSSIBLE"
	// 
	// 
	// 
	// 6)
	// {0,0,0,0,1,1,2,3,3,3,4,4,4,5,9,9,14,14,14,16,20}
	// {-1,2,-1,-1,-1,-1,-1,1,1,-1,-1,-1,3,1,-1,1,9,-1,-1,4,-1,-1}
	// 
	// Returns: "IMPOSSIBLE"
	// 
	// 
	// 
	// 7)
	// {0,0,1,1}
	// {-1,-1,5,-1,-1}
	// 
	// Returns: "POSSIBLE"
	// 
	// No cutting necessary.
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
