import java.util.Vector;

public class WinterAndReindeers {
    /**
     * SRM 601
     * LCS with additional constraints
     * dp[lenA][lenB][progress of C]
     *
     * @param allA
     * @param allB
     * @param allC
     * @return
     */

    public int getNumber(String[] allA, String[] allB, String[] allC) {
        String sa = "";
        String sb = "";
        String sc = "";

        for (String a : allA) sa += a;
        for (String b : allB) sb += b;
        for (String c : allC) sc += c;

        final int an = sa.length();
        final int bn = sb.length();
        final int cn = sc.length();

        char[] A = sa.toCharArray();
        char[] B = sb.toCharArray();
        char[] C = sc.toCharArray();

        Vector<Integer> foundA = findAll(A, C, an, cn);

        Vector<Integer> foundB = findAll(B, C, bn, cn);

        int[][] dpForward = new int[an + 1][bn + 1];
        //  LCS
        for (int i = 1; i <= an; i++) {
            for (int j = 1; j <= bn; j++) {
                if (A[i - 1] == B[j - 1]) {
                    dpForward[i][j] = dpForward[i - 1][j - 1] + 1;
                } else {
                    dpForward[i][j] = Math.max(dpForward[i - 1][j], dpForward[i][j - 1]);
                }
            }
        }

        int[][] dpReverse = new int[an + 1][bn + 1];

        for (int i = an - 1; i >= 0; i--) {
            for (int j = bn - 1; j >= 0; j--) {
                if (A[i] == B[j]) {
                    dpReverse[i][j] = dpReverse[i + 1][j + 1] + 1;
                } else {
                    dpReverse[i][j] = Math.max(dpReverse[i + 1][j], dpReverse[i][j + 1]);
                }
            }
        }

        int ret = 0;

        for (int i = 0; i < foundA.size(); i += 2) {
            for (int j = 0; j < foundB.size(); j += 2) {
                int fa1 = foundA.get(i);
                int fa2 = foundA.get(i + 1);
                int fb1 = foundB.get(j);
                int fb2 = foundB.get(j + 1);
                ret = Math.max(ret, cn + dpForward[fa1][fb1] + dpReverse[fa2][fb2]);
            }
        }

        System.out.println(foundA);
        System.out.println(foundB);
        System.out.println();
        return ret;
    }

    public Vector<Integer> findAll(char[] S, char[] C, final int sn, final int cn) {
        Vector<Integer> found = new Vector<Integer>();

        for (int i = 0; i < sn; i++) {
            if (S[i] == C[0]) {
                int temp = substring(S, C, sn, cn, i + 1);
                if (temp != -1) {
                    found.add(i);
                    found.add(temp);
                }
            }
        }

        return found;
    }

    public int substring(char[] S, char[] C, final int sn, final int cn, int i) {
        int count = 1;

        for (; i < sn && count < cn; i++) {
            if (S[i] == C[count]) {
                count++;
            }
            if (sn - i < cn - count) {
                return -1;
            }
        }

        if (count < cn) return -1;

        return i;
    }

    // BEGIN KAWIGIEDIT TESTING
    // Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
    private static boolean KawigiEdit_RunTest(int testNum, String[] p0, String[] p1, String[] p2, boolean hasAnswer, int p3) {
        System.out.print("Test " + testNum + ": [" + "{");
        for (int i = 0; p0.length > i; ++i) {
            if (i > 0) {
                System.out.print(",");
            }
            System.out.print("\"" + p0[i] + "\"");
        }
        System.out.print("}" + "," + "{");
        for (int i = 0; p1.length > i; ++i) {
            if (i > 0) {
                System.out.print(",");
            }
            System.out.print("\"" + p1[i] + "\"");
        }
        System.out.print("}" + "," + "{");
        for (int i = 0; p2.length > i; ++i) {
            if (i > 0) {
                System.out.print(",");
            }
            System.out.print("\"" + p2[i] + "\"");
        }
        System.out.print("}");
        System.out.println("]");
        WinterAndReindeers obj;
        int answer;
        obj = new WinterAndReindeers();
        long startTime = System.currentTimeMillis();
        answer = obj.getNumber(p0, p1, p2);
        long endTime = System.currentTimeMillis();
        boolean res;
        res = true;
        System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
        if (hasAnswer) {
            System.out.println("Desired answer:");
            System.out.println("\t" + p3);
        }
        System.out.println("Your answer:");
        System.out.println("\t" + answer);
        if (hasAnswer) {
            res = answer == p3;
        }
        if (!res) {
            System.out.println("DOESN'T MATCH!!!!");
        } else if ((endTime - startTime) / 1000.0 >= 2) {
            System.out.println("FAIL the timeout");
            res = false;
        } else if (hasAnswer) {
            System.out.println("Match :-)");
        } else {
            System.out.println("OK, but is it right?");
        }
        System.out.println("");
        return res;
    }

    public static void main(String[] args) {
        boolean all_right;
        all_right = true;

        String[] p0;
        String[] p1;
        String[] p2;
        int p3;

        // ----- test 0 -----
        p0 = new String[] {"X"};
        p1 = new String[] {"X", "Y"};
        p2 = new String[] {"X"};
        p3 = 1;
        all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
        // ------------------

        // ----- test 1 -----
        p0 = new String[] {"ABCXD"};
        p1 = new String[] {"BCDEF"};
        p2 = new String[] {"CD"};
        p3 = 3;
        all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
        // ------------------

        // ----- test 2 -----
        p0 = new String[] {"WE", "LOVE"};
        p1 = new String[] {"WORKING", "FOR", "SANTA"};
        p2 = new String[] {"JK"};
        p3 = 0;
        all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
        // ------------------

        // ----- test 3 -----
        p0 = new String[] {"ABCDE"};
        p1 = new String[] {"CDEAB"};
        p2 = new String[] {"B"};
        p3 = 2;
        all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
        // ------------------

        // ----- test 4 -----
        p0 = new String[] {"ABCABDEGAXAHDJBAAHFJDXBB", "ABHFHCDALFDJDBBA", "BABBAXAXXX"};
        p1 = new String[] {"ABLOCBAXBAHAJDXBIJKA", "JBABCDAHKFIUDALPJAH", "AABACX"};
        p2 = new String[] {"AXBADXBBAB", "CDD"};
        p3 = 23;
        all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
        // ------------------

        if (all_right) {
            System.out.println("You're a stud (at least on the example cases)!");
        } else {
            System.out.println("Some of the test cases had errors.");
        }
    }
    // PROBLEM STATEMENT
    //
    // It's winter time! Time to play some games.
    //
    //
    //
    //
    // Four reindeers are playing the following game.
    // The first three of them choose three non-empty strings: A, B, and C. (The strings are not necessarily distinct.)
    // Then, the fourth one (and it happens to be the youngest one) finds a string S that satisfies the following conditions:
    //
    //
    //
    // S is a subsequence of A. (I.e., either S equals A, or S can be obtained from A by removing some of its characters.)
    //
    //
    // S is a subsequence of B.
    //
    //
    // C is a (contiguous) substring of S.
    //
    //
    // There is no string longer than S that satisfies the previous three conditions.
    //
    //
    //
    //
    //
    // You are given three String[]s allA, allB and allC.
    // Concatenate all elements of allA, allB and allC to obtain strings A, B and C, respectively.
    // Return the length of the string S.
    // If there is no such string, return 0.
    //
    //
    // DEFINITION
    // Class:WinterAndReindeers
    // Method:getNumber
    // Parameters:String[], String[], String[]
    // Returns:int
    // Method signature:int getNumber(String[] allA, String[] allB, String[] allC)
    //
    //
    // CONSTRAINTS
    // -allA, allB and allC will each contain between 1 and 50 elements, inclusive.
    // -Each element of allA, allB and allC will contain between 1 and 50 characters, inclusive.
    // -Each element of allA, allB and allC will consist only of uppercase English letters ('A'-'Z').
    //
    //
    // EXAMPLES
    //
    // 0)
    // {"X"}
    // {"X", "Y"}
    // {"X"}
    //
    // Returns: 1
    //
    // In this case, A = "X", B = "XY", C = "X". The longest possible string that satisfies conditions from the statement is "X". Thus, the answer is 1.
    //
    // 1)
    // {"ABCXD"}
    // {"BCDEF"}
    // {"CD"}
    //
    // Returns: 3
    //
    // The longest possible string in this case is "BCD".
    //
    // 2)
    // {"WE", "LOVE"}
    // {"WORKING", "FOR", "SANTA"}
    // {"JK"}
    //
    // Returns: 0
    //
    // No string satisfies all criteria in this case. Thus, the answer is 0.
    //
    // 3)
    // {"ABCDE"}
    // {"CDEAB"}
    // {"B"}
    //
    // Returns: 2
    //
    //
    //
    // 4)
    // {"ABCABDEGAXAHDJBAAHFJDXBB", "ABHFHCDALFDJDBBA", "BABBAXAXXX"}
    // {"ABLOCBAXBAHAJDXBIJKA", "JBABCDAHKFIUDALPJAH", "AABACX"}
    // {"AXBADXBBAB", "CDD"}
    //
    // Returns: 23
    //
    //
    //
    // END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
