import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class TheBrickTowerMediumDivTwo
{
	public int[] find(int[] heights)
	{
        int n = heights.length;
		int[] perm = new int[n];
        for (int i = 0; i < n; i++) {
            perm[i] = i;
        }
        int ret = (int) 1e9;
        int[] arrRet = new int[n];
        do {
            int currRet = 0;
            for (int i = 1; i < n; i++) {
                currRet += Math.max(heights[perm[i - 1]], heights[perm[i]]);
            }
            if (currRet < ret) {
                ret = currRet;
                for (int i = 0; i < n; i++) {
                    arrRet[i] = perm[i];
                }
            }
        } while (nextPermutation(perm) == 1);
        return arrRet;
	}

    // get the next permutation in place
    public static int nextPermutation(int[] num) {
        int size = num.length;
        if (size <= 1) return 0;

        // 1.find the first acending order pair from the bottom
        int low = size - 2;
        int high = size - 1;
        while (num[low] >= num[high]) {
            if (low == high - 1) {
                low -= 1;
                high = size - 1;
                if (low < 0) break;
            } else {
                high -= 1;
            }
        }

        // reached end of permutation
        if (low < 0) {
            Arrays.sort(num);
            return 0;
        }

        // 2.swap num[lo] with num[hi] if lo >= 0
        int temp = 0;
        temp = num[low];
        num[low] = num[high];
        num[high] = temp;

        // 3.reverse lo+1 .. end
        low = low + 1;
        high = size - 1;
        while (low < high) {
            temp = num[low];
            num[low] = num[high];
            num[high] = temp;
            low++;
            high--;
        }

        return 1;
    }
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, int[] p0, boolean hasAnswer, int[] p1) {
		System.out.print("Test " + testNum + ": [" + "{");
		for (int i = 0; p0.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p0[i]);
		}
		System.out.print("}");
		System.out.println("]");
		TheBrickTowerMediumDivTwo obj;
		int[] answer;
		obj = new TheBrickTowerMediumDivTwo();
		long startTime = System.currentTimeMillis();
		answer = obj.find(p0);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.print("\t" + "{");
			for (int i = 0; p1.length > i; ++i) {
				if (i > 0) {
					System.out.print(",");
				}
				System.out.print(p1[i]);
			}
			System.out.println("}");
		}
		System.out.println("Your answer:");
		System.out.print("\t" + "{");
		for (int i = 0; answer.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(answer[i]);
		}
		System.out.println("}");
		if (hasAnswer) {
			if (answer.length != p1.length) {
				res = false;
			} else {
				for (int i = 0; answer.length > i; ++i) {
					if (answer[i] != p1[i]) {
						res = false;
					}
				}
			}
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		int[] p0;
		int[] p1;
		
		// ----- test 0 -----
		p0 = new int[]{4,7,5};
		p1 = new int[]{0,2,1};
		all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = new int[]{4,4,4,4,4,4,4};
		p1 = new int[]{0,1,2,3,4,5,6};
		all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = new int[]{2,3,3,2};
		p1 = new int[]{0,3,1,2};
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = new int[]{13,32,38,25,43,47,6};
		p1 = new int[]{0,6,3,1,2,4,5};
		all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
		// ------------------
		
		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// 
	// John and Brus just built some towers using toy bricks.
	// They now have n towers numbered 0 through n-1.
	// For each i, the height of the i-th tower (0-based index) is given in heights[i].
	// 
	// 
	// 
	// John and Brus want to arrange their towers into a line.
	// That is, the bottoms of the towers will all stand on the same line.
	// John and Brus don't like it when a tower falls down and knocks over another tower while falling.
	// To avoid this, they have to put their towers sufficiently far apart.
	// More precisely, the distance between any two neighboring towers must be at least equal to the maximum of their heights.
	// John and Brus would like to minimize the distance between the first and the last tower in the line.
	// 
	// 
	// 
	// You are given the int[] heights.
	// Return a int[] containing exactly n elements: the order in which the towers should be placed on the line.
	// For each i, the i-th element of the return value should be the number of the tower that will be placed i-th on the line.
	// If there is a tie (multiple solutions give the same minimal distance), return the lexicographically smallest order.
	// 
	// 
	// 
	// DEFINITION
	// Class:TheBrickTowerMediumDivTwo
	// Method:find
	// Parameters:int[]
	// Returns:int[]
	// Method signature:int[] find(int[] heights)
	// 
	// 
	// NOTES
	// -A int[] A is lexicographically smaller than a int[] B if it contains a smaller element at the first position where these int[]s differ.
	// 
	// 
	// CONSTRAINTS
	// -heights will contain between 1 and 7 elements, inclusive.
	// -Each element of heights will be between 1 and 47 inclusive.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// {4, 7, 5}
	// 
	// Returns: {0, 2, 1 }
	// 
	// There are six possible orderings, but only four of them have optimal distance 12 between the first and the last towers:
	// 
	// {0, 2, 1}
	// {1, 0, 2}
	// {1, 2, 0}
	// {2, 0, 1}
	// 
	// Among these orderings {0, 2, 1} is the lexicographically smallest one.
	// 
	// 
	// 1)
	// {4, 4, 4, 4, 4, 4, 4}
	// 
	// Returns: {0, 1, 2, 3, 4, 5, 6 }
	// 
	// Towers may have equal heights.
	// 
	// 
	// 2)
	// {2, 3, 3, 2}
	// 
	// Returns: {0, 3, 1, 2 }
	// 
	// Towers of height 2 have to be neighboring in the optimal ordering.
	// 
	// 3)
	// {13, 32, 38, 25, 43, 47, 6}
	// 
	// Returns: {0, 6, 3, 1, 2, 4, 5 }
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
