import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class TrafficCongestionDivTwo {
    public long theMinCars(int treeHeight) {
        long[] ret = new long[66];
        ret[0] = 1L;
        ret[1] = 1L;
        ret[2] = 3L;
        if (treeHeight >= 3) {
            // greedy, remove top layer
            for (int i = 3; i <= treeHeight; i++) {
                ret[i] = 1;
                for (int j = 0; j <= i - 2; j++) {
                    ret[i] += 2 * ret[j];
                }
            }
        }
        return ret[treeHeight];
    }

    // BEGIN KAWIGIEDIT TESTING
    // Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
    private static boolean KawigiEdit_RunTest(int testNum, int p0, boolean hasAnswer, long p1) {
        System.out.print("Test " + testNum + ": [" + p0);
        System.out.println("]");
        TrafficCongestionDivTwo obj;
        long answer;
        obj = new TrafficCongestionDivTwo();
        long startTime = System.currentTimeMillis();
        answer = obj.theMinCars(p0);
        long endTime = System.currentTimeMillis();
        boolean res;
        res = true;
        System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
        if (hasAnswer) {
            System.out.println("Desired answer:");
            System.out.println("\t" + p1);
        }
        System.out.println("Your answer:");
        System.out.println("\t" + answer);
        if (hasAnswer) {
            res = answer == p1;
        }
        if (!res) {
            System.out.println("DOESN'T MATCH!!!!");
        } else if ((endTime - startTime) / 1000.0 >= 2) {
            System.out.println("FAIL the timeout");
            res = false;
        } else if (hasAnswer) {
            System.out.println("Match :-)");
        } else {
            System.out.println("OK, but is it right?");
        }
        System.out.println("");
        return res;
    }

    public static void main(String[] args) {
        boolean all_right;
        all_right = true;

        int p0;
        long p1;

        // ----- test 0 -----
        p0 = 1;
        p1 = 1L;
        all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
        // ------------------

        // ----- test 1 -----
        p0 = 2;
        p1 = 3L;
        all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
        // ------------------

        // ----- test 2 -----
        p0 = 3;
        p1 = 5L;
        all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
        // ------------------

        // ----- test 3 -----
        p0 = 10;
        p1 = 683L;
        all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
        // ------------------

        // ----- test 4 -----
        p0 = 60;
        p1 = 768614336404564651L;
        all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
        // ------------------

        if (all_right) {
            System.out.println("You're a stud (at least on the example cases)!");
        } else {
            System.out.println("Some of the test cases had errors.");
        }
    }
    // PROBLEM STATEMENT
    // There are some cities and some roads connecting them together.
    // The road network has the topology of a perfect binary tree (see below for a picture), in which the cities are nodes and the roads are edges.
    //
    // You are given the int treeHeight giving the height of the tree.
    // (The height of a perfect binary tree is the number of edges on the path between the root node and any leaf node.)
    // Thus, there are 2^(treeHeight+1)-1 cities and 2^(treeHeight+1)-2 roads in total.
    //
    // The picture below shows how the road network looks like when treeHeight = 2.
    //
    //
    //
    // We want to send some cars into the road network.
    // Each car will be traveling from its starting city to its destination city without visiting the same city twice.
    // (Note that the route of each car is uniquely determined by its starting and its destination city.)
    // It is possible for the starting city to be equal to the destination city, in that case the car only visits that single city.
    //
    // Our goal is to send out the cars in such a way that each city will be visited by exactly one car. Compute and return the smallest number of cars we need in order to do so.
    //
    //
    // DEFINITION
    // Class:TrafficCongestionDivTwo
    // Method:theMinCars
    // Parameters:int
    // Returns:long
    // Method signature:long theMinCars(int treeHeight)
    //
    //
    // NOTES
    // -The answer will always fit into a 64-bit signed integer data type.
    //
    //
    // CONSTRAINTS
    // -treeHeight will be between 0 and 60, inclusive.
    //
    //
    // EXAMPLES
    //
    // 0)
    // 1
    //
    // Returns: 1
    //
    // In this case, one car can visit all the cities.
    //
    //
    //
    //
    //
    // 1)
    // 2
    //
    // Returns: 3
    //
    // Here is one way to visit all cities exactly once by three cars:
    //
    //
    //
    //
    // 2)
    // 3
    //
    // Returns: 5
    //
    //
    //
    // 3)
    // 10
    //
    // Returns: 683
    //
    //
    //
    // 4)
    // 60
    //
    // Returns: 768614336404564651
    //
    //
    //
    // END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
