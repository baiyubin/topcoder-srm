import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class BlockTower
{
	public int getTallest(int[] blockHeights)
	{
        int ret = 0;
        int[][] dp = new int[51][51];
        for (int i = 1; i <= blockHeights.length; i++) {
            for (int j = 1; j <= 50; j++) {
                int curr = blockHeights[i - 1];
                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);
                if (curr % 2 == 0 && j % 2 == 1) {
                    continue;
                } else {
                    dp[i][curr] = Math.max(
                            dp[i][curr],
                            dp[i - 1][j] + curr
                    );
                    ret = Math.max(ret, dp[i][curr]);
                }
            }
        }
        return ret;
	}
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, int[] p0, boolean hasAnswer, int p1) {
		System.out.print("Test " + testNum + ": [" + "{");
		for (int i = 0; p0.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p0[i]);
		}
		System.out.print("}");
		System.out.println("]");
		BlockTower obj;
		int answer;
		obj = new BlockTower();
		long startTime = System.currentTimeMillis();
		answer = obj.getTallest(p0);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p1);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p1;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		int[] p0;
		int p1;
		
		// ----- test 0 -----
		p0 = new int[]{4,7};
		p1 = 11;
		all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = new int[]{7,4};
		p1 = 7;
		all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = new int[]{7};
		p1 = 7;
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = new int[]{4};
		p1 = 4;
		all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 4 -----
		p0 = new int[]{48,1,50,1,50,1,48};
		p1 = 196;
		all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 5 -----
		p0 = new int[]{49,2,49,2,49};
		p1 = 147;
		all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 6 -----
		p0 = new int[]{44,3,44,3,44,47,2,47,2,47,2};
		p1 = 273;
		all_right = KawigiEdit_RunTest(6, p0, true, p1) && all_right;
		// ------------------
		
		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// Josh loves playing with blocks. Currently, he has N blocks, labeled 0 through N-1. The heights of all blocks are positive integers. More precisely, for each i, the height of block i is blockHeights[i]. Josh is interested in making the tallest block tower possible. He likes all his towers to follow three simple rules:
	// 
	// The blocks must be stacked in a single column, one atop another. The height of the tower is simply the sum of heights of all its blocks.
	// The labels of blocks used in the tower must increase from the bottom to the top. In other words, whenever Josh places box x on top of box y, we have x > y.
	// Josh will never place a box of an even height on top of a box of an odd height.
	// 
	// You are given the int[] blockHeights. Return the height of the tallest possible block tower Josh can build.
	// 
	// DEFINITION
	// Class:BlockTower
	// Method:getTallest
	// Parameters:int[]
	// Returns:int
	// Method signature:int getTallest(int[] blockHeights)
	// 
	// 
	// CONSTRAINTS
	// -blockHeights will contain between 1 and 50 elements, inclusive.
	// -Each element of blockHeights will be between 1 and 50, inclusive.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// {4,7}
	// 
	// Returns: 11
	// 
	// The optimal tower contains both blocks. Block 0 is on the bottom of the tower.
	// 
	// 1)
	// {7,4}
	// 
	// Returns: 7
	// 
	// This time the optimal tower contains just block 0. Josh cannot put block 1 on top of it, because 4 is even and 7 is odd.
	// 
	// 2)
	// {7}
	// 
	// Returns: 7
	// 
	// 
	// 
	// 3)
	// {4}
	// 
	// Returns: 4
	// 
	// 
	// 
	// 4)
	// {48,1,50,1,50,1,48}
	// 
	// Returns: 196
	// 
	// Note that in a valid tower the labels of the blocks have to increase from bottom to top. Their heights do not have to. In this case the optimal tower consists of blocks 0, 2, 4, and 6, in this order. Its total height is 48 + 50 + 50 + 48 = 196.
	// 
	// 5)
	// {49,2,49,2,49}
	// 
	// Returns: 147
	// 
	// 
	// 
	// 6)
	// {44,3,44,3,44,47,2,47,2,47,2}
	// 
	// Returns: 273
	// 
	// 
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
