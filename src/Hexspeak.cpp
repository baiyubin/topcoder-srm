#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;


class Hexspeak {
public:
  string decode(long long ciphertext) {
    stringstream ret_stream;

    map<int, char> m = {
      {0, 'O'},
      {1, 'I'},
      {10, 'A'},
      {11, 'B'},
      {12, 'C'},
      {13, 'D'},
      {14, 'E'},
      {15, 'F'},
    };

    int digit = 0;
    while (ciphertext > 0) {
      digit = ciphertext % 16;
      ciphertext /= 16;
      if (m.count(digit) > 0) {
	ret_stream << m[digit];
      } else {
	return "Error!";
      }
    }
    string ret = ret_stream.str();
    reverse(ret.begin(), ret.end());
    return ret;
  }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, long long p0, bool hasAnswer, string p1) {
  cout << "Test " << testNum << ": [" << p0;
  cout << "]" << endl;
  Hexspeak *obj;
  string answer;
  obj = new Hexspeak();
  clock_t startTime = clock();
  answer = obj->decode(p0);
  clock_t endTime = clock();
  delete obj;
  bool res;
  res = true;
  cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
  if (hasAnswer) {
    cout << "Desired answer:" << endl;
    cout << "\t" << "\"" << p1 << "\"" << endl;
  }
  cout << "Your answer:" << endl;
  cout << "\t" << "\"" << answer << "\"" << endl;
  if (hasAnswer) {
    res = answer == p1;
  }
  if (!res) {
    cout << "DOESN'T MATCH!!!!" << endl;
  } else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
    cout << "FAIL the timeout" << endl;
    res = false;
  } else if (hasAnswer) {
    cout << "Match :-)" << endl;
  } else {
    cout << "OK, but is it right?" << endl;
  }
  cout << "" << endl;
  return res;
}
int main() {
  bool all_right;
  all_right = true;
	
  long long p0;
  string p1;
	
  {
    // ----- test 0 -----
    p0 = 257ll;
    p1 = "IOI";
    all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 1 -----
    p0 = 258ll;
    p1 = "Error!";
    all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 2 -----
    p0 = 3405691582ll;
    p1 = "CAFEBABE";
    all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 3 -----
    p0 = 2882400001ll;
    p1 = "ABCDEFOI";
    all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 4 -----
    p0 = 999994830345994239ll;
    p1 = "DEOBIFFFFFFFFFF";
    all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 5 -----
    p0 = 1000000000000000000ll;
    p1 = "Error!";
    all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
    // ------------------
  }
	
  if (all_right) {
    cout << "You're a stud (at least on the example cases)!" << endl;
  } else {
    cout << "Some of the test cases had errors." << endl;
  }
  return 0;
}
// PROBLEM STATEMENT
// If you compile a Java program and open the .class file in a text editor, you will find that the first four bytes spell "CAFEBABE" in hexadecimal.
// Using hexadecimal numbers to spell words is called Hexspeak.
// 
// 
// Hexadecimal numbers are integers written in base 16.
// The letters 'A' through 'F' represent the digits with values 10 through 15.
// For example, the integer 202 written in hexadecimal is "CA".
// This is because 202 = 12*16 + 10, and the digits 12 and 10 are written as 'C' and 'A', respectively.
// 
// 
// In this problem we will use eight different letters: in addition to the letters 'A' through 'F' we will also interpret the digit 0 as the letter 'O' and the digit 1 as the letter 'I'.
// Hence, any word that only consists of the letters ABCDEFIO can be interpreted as a hexadecimal number.
// Such words are called valid hexspeak words.
// 
// 
// Fox Ciel has a long long ciphertext containing a positive integer.
// Convert this number to hexadecimal.
// If you get the representation of a valid hexspeak word, return that word.
// Otherwise, return the string "Error!" (quotes for clarity).
// In other words, you should return "Error!" if the hexadecimal representation of ciphertext contains some occurrence of a digit between 2 and 9, inclusive.
// 
// DEFINITION
// Class:Hexspeak
// Method:decode
// Parameters:long long
// Returns:string
// Method signature:string decode(long long ciphertext)
// 
// 
// NOTES
// -The correct hexadecimal representation of ciphertext does not contain any leading zeros.
// -The return value is case-sensitive.
// 
// 
// CONSTRAINTS
// -ciphertext will be between 1 and 1,000,000,000,000,000,000, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 257
// 
// Returns: "IOI"
// 
// The number 257 in decimal is written as 101 in hexadecimal.
// The digits 1 and 0 represent the characters 'I' and 'O', thus we should return "IOI".
// 
// 1)
// 258
// 
// Returns: "Error!"
// 
// The number 258 in decimal is written as 102 in hexadecimal.
// The digit 2 does not represent a letter, so we return "Error!".
// 
// 2)
// 3405691582
// 
// Returns: "CAFEBABE"
// 
// 
// 
// 3)
// 2882400001
// 
// Returns: "ABCDEFOI"
// 
// 
// 
// 4)
// 999994830345994239
// 
// Returns: "DEOBIFFFFFFFFFF"
// 
// 
// 
// 5)
// 1000000000000000000
// 
// Returns: "Error!"
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
