import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class SortishDiv2
{
	/**
	 * srm 636
	 * @param  sortedness [description]
	 * @param  seq        [description]
	 * @return            [description]
	 */
	public int ways(int sortedness, int[] seq)
	{
		
	}
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, int p0, int[] p1, boolean hasAnswer, int p2) {
		System.out.print("Test " + testNum + ": [" + p0 + "," + "{");
		for (int i = 0; p1.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p1[i]);
		}
		System.out.print("}");
		System.out.println("]");
		SortishDiv2 obj;
		int answer;
		obj = new SortishDiv2();
		long startTime = System.currentTimeMillis();
		answer = obj.ways(p0, p1);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p2);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p2;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		int p0;
		int[] p1;
		int p2;
		
		// ----- test 0 -----
		p0 = 5;
		p1 = new int[]{4,0,0,2,0};
		p2 = 2;
		all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = 4;
		p1 = new int[]{0,0,0,0};
		p2 = 5;
		all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = 2;
		p1 = new int[]{1,3,2};
		p2 = 1;
		all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = 2;
		p1 = new int[]{1,2,0,5,0,0};
		p2 = 0;
		all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
		// ------------------
		
		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// Everyone likes some sequences more than others.
	// Every person has their own function which tells them how good a sequence is.
	// For example, for some people this function could simply be the count of negative numbers in the sequence.
	// 
	// Jezalb's most favorite sequences are ones that are sorted in increasing order.
	// When he sees a sequence S, he immediately calculates the number of pairs of indexes i < j such that S[i] < S[j].
	// He calls this number the "sortedness" of S.
	// 
	// This morning Jezalb entered a classroom and saw a permutation of 1 through N on the blackboard.
	// He quickly calculated its sortedness.
	// He then left the classroom and forgot the permutation.
	// He only remembered the sortedness he computed.
	// You are given this value in a int sortedness. 
	// 
	// Later that day Jezalb reentered the classroom and saw a sequence on the blackboard.
	// The sequence was a permutation of 1 through N, but with some elements erased.
	// You are given this sequence as a int[] seq with N elements.
	// Some of the elements in seq may be 0, which indicates an erased number.
	// 
	// Jezalb thinks that the sequence seq may have been obtained by erasing some elements of the sequence he saw during his first visit to the classroom.
	// He would like to restore the erased elements.
	// 
	// You are given the int sortedness and the int[] seq.
	// Return the number of ways in which he can fill in the missing elements into seq in such a way that the sortedness of the obtained permutation will be exactly sortedness.
	// 
	// DEFINITION
	// Class:SortishDiv2
	// Method:ways
	// Parameters:int, int[]
	// Returns:int
	// Method signature:int ways(int sortedness, int[] seq)
	// 
	// 
	// CONSTRAINTS
	// -sortedness will be between 0 and 1,000,000,000, inclusive. 
	// -seq will contain between 1 and 100 elements, inclusive. 
	// -Elements in seq will be between 0 and number of elements in seq, inclusive. 
	// -Positive elements in seq will be distinct. 
	// -Number of elements equal to 0 in seq will be between 0 and 5, inclusive.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// 5
	// {4, 0, 0, 2, 0}
	// 
	// Returns: 2
	// 
	// There are six ways to fill in the missing elements. Out of those six permutations, only two have sortedness 5: {4, 1, 5, 2, 3} and {4, 3, 1, 2, 5}.
	// 
	// 1)
	// 4
	// {0, 0, 0, 0}
	// 
	// Returns: 5
	// 
	// All 5 possible ways are: {1, 3, 4, 2}, {1, 4, 2, 3}, {2, 1, 4, 3}, {2, 3, 1, 4}, {3, 1, 2, 4}.
	// 
	// 2)
	// 2
	// {1, 3, 2}
	// 
	// Returns: 1
	// 
	// There are no gaps and sortedness is indeed equal to 2.
	// 
	// 3)
	// 2
	// {1, 2, 0, 5, 0, 0}
	// 
	// Returns: 0
	// 
	// Regardless of how he fills in the gaps, the sortedness of the resulting permutation will always be greater than 2.
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
