import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class SpecialStrings
{
	int n;
	/**
	 * observe:
	 * 	first bit must be 0, last bit must be 0
     * 	a digit can be '0' iff we can make a valid string by filling the rest as 111...
     * 	same goes for deciding a digit to be '1'
	 * @param  current [description]
	 * @return         [description]
	 */
	public String findNext(String current)
	{
		n = current.length();
		StringBuilder sb = new StringBuilder();
		for (int i = n - 1; i >= 0; i--) {
			if (current.charAt(i) == '1') continue;
            sb.append(current.substring(0, i));

			if (canWork(sb, '1')) {
                sb = new StringBuilder(current.substring(0, i));
                sb.append('1');
                break;
			} else if (i == 0) {
                return "";
            }
		}
        for (int i = sb.length(); i < n; i++) {
             if (canWork(sb, '0')) {
                    sb.append('0');
             } else {
                    sb.append('1');
             }
        }
		return sb.toString();
	}

    private boolean canWork(StringBuilder sb, char c) {
        StringBuilder sb2 = new StringBuilder(sb);
        sb2.append(c);
        while (sb2.length() < n) {
            sb2.append('1');
        }
        return isValid(sb2.toString());
    }

    public boolean isValid(String s) {
		int len = s.length();
		for (int i = 1; i < len; ++i) {
			String s1 = s.substring(0,i);
			String s2 = s.substring(i,len);
			if (s1.compareTo(s2) >= 0) {
				return false;
			}
		}
		return true;
	}
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, String p0, boolean hasAnswer, String p1) {
		System.out.print("Test " + testNum + ": [" + "\"" + p0 + "\"");
		System.out.println("]");
		SpecialStrings obj;
		String answer;
		obj = new SpecialStrings();
		long startTime = System.currentTimeMillis();
		answer = obj.findNext(p0);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + "\"" + p1 + "\"");
		}
		System.out.println("Your answer:");
		System.out.println("\t" + "\"" + answer + "\"");
		if (hasAnswer) {
			res = answer.equals(p1);
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		String p0;
		String p1;
		
		// ----- test 0 -----
		p0 = "01";
		p1 = "";
		all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = "00101";
		p1 = "00111";
		all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = "0010111";
		p1 = "0011011";
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = "000010001001011";
		p1 = "000010001001101";
		all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 4 -----
		p0 = "01101111011110111";
		p1 = "01101111011111111";
		all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
		// ------------------
		
		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// 
	// A string S is called special if it satisfies the following two properties:
	// 
	// Each character in S is either '0' or '1'.
	// Whenever S = UV where both U and V are nonempty strings, U is strictly smaller than V in lexicographic order.
	// 
	// 
	// 
	// 
	// For example, the string S = "00101" is special because we have "0" < "0101", "00" < "101", "001" < "01", and "0010" < "1".
	// 
	// 
	// 
	// You are given a String current that is guaranteed to be special.
	// Let N be the length of current.
	// Consider the lexicographically sorted list of all special strings of length N.
	// Compute and return the string that comes immediatelly after current in this list.
	// If current happens to be the last string in the list, return an empty String instead.
	// 
	// 
	// DEFINITION
	// Class:SpecialStrings
	// Method:findNext
	// Parameters:String
	// Returns:String
	// Method signature:String findNext(String current)
	// 
	// 
	// NOTES
	// -Given two different strings U and V, the string U precedes the string V in lexicographic order if one of two conditions is satisfied: Either U is a proper prefix of V, or there is an integer x such that U and V have the same first x characters, and the x+1th character in U is smaller than the x+1th character in V.
	// 
	// 
	// CONSTRAINTS
	// -current will contain between 1 and 50 characters, inclusive.
	// -current will be a special string.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// "01"
	// 
	// Returns: ""
	// 
	// "01" is the only special string of length 2.
	// 
	// 1)
	// "00101"
	// 
	// Returns: "00111"
	// 
	// The special strings of length 5 are "00001", "00011", "00101", "00111", "01011", "01111".
	// 
	// 2)
	// "0010111"
	// 
	// Returns: "0011011"
	// 
	// 
	// 
	// 3)
	// "000010001001011"
	// 
	// Returns: "000010001001101"
	// 
	// 
	// 
	// 4)
	// "01101111011110111"
	// 
	// Returns: "01101111011111111"
	// 
	// 
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
